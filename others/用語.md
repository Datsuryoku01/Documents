# 意味がわからない専門用語

## 用語

### キャスト
型変換　　(type 関数) 

### インクリメント 
変数に1を加えること。a += 1　と記する 

### 変数 
- 宣⾔ : 変数を作成すること     
- 代⼊ : 変数に値をいれること 
- 再代⼊ : すでに変数を持つ変数に値をいれること 
- 代⼊演算⼦ : 変数に値を代⼊する記号。「=」のこと 
- 返す : 変数から値を取り出すこと 
- フラグ : 「オン（on）」か「オフ（off）」のどちらかを表す値が入り、2つの状態のどちらかを判断するために使う変数を指す俗称  
  1. オン（on）の状態 → true, オフ（off）の状態 → false
  2. オン（on）の状態 → 1, オフ（off）の状態 → 0 

### ダンプ 
エラー内容やデバッグ中の値を出力するときは「ダンプ」と表現することが多い。「ダンプ」って単語が出てきたら「なんか出力された」と考える。 

### ラッパー
元の関数やライブラリを覆い隠す役割を果す。ソフトウェアやプログラム部品などが提供するクラスや関数、データ型などを、本来とは異なる環境や方法で利用できるようにしたものをラッパーという。 

### パース
プログラムのソースコードやXML文書など、一定の文法に従って記述された複雑な構造のテキスト文書を解析し、プログラムで扱えるようなデータ構造の集合体に変換すること 

### スキーマ 
データベースの構造であり、データベース管理システム でサポートされている形式言語で記述される。関係データベースでは、スキーマは関係 と関係内の属性 、属性や関係の関連の定義である。 
データベースにどのような種類のデータをどのような構造で格納するか定義したものをスキーマという 

### クエリ 
データベースを利用する場合のクエリとは、データベース管理システム（DBMS）に「抽出」や「更新」といった処理を要求する際の命令文を指します。 
ITではソフトウェアに対するデータの問い合わせや要求などを一定の形式で文字に表現することを意味する。

### トークン 
コンパイラ開発における「トークン」とは、ソースコードの構成要素を表す基本的な単位です。トークンは、ソースコードを構文解析しやすくするために、文字列を意味のある部分に分割する役割を果たします。  
具体的には、トークンは以下のような要素で構成されることが多いです：  

1. **キーワード**：言語の構文で特別な意味を持つ単語（例：`if`、`while`、`return`など）。
2. **識別子**：変数名や関数名など、プログラム内で特定の意味を持つ名前（例：`myVariable`、`calculateSum`など）。
3. **リテラル**：定数値や文字列など、具体的な値（例：`42`、`"Hello, world!"`など）。
4. **演算子**：数値や変数に対して行う操作を示す記号（例：`+`、`-`、`*`など）。
5. **区切り記号**：構文の境界を示す記号（例：`;`、`,`、`()`など）。

コンパイラの最初の段階である「字句解析（レキサー）」では、ソースコードをトークンに分割します。これにより、次の段階である「構文解析（パーサー」で、コードの構造を理解しやすくなります。

例えば、以下のようなコード行があるとします：

```c
int sum = a + b;
```

このコード行は、トークンに分割されると次のようになります：

- `int` （キーワード）
- `sum` （識別子）
- `=` （演算子）
- `a` （識別子）
- `+` （演算子）
- `b` （識別子）
- `;` （区切り記号）

このようにトークンは、コンパイラがソースコードを理解し、適切に処理するための基盤となります。

### 構文解析

コンパイラ開発における「構文解析（パーシング）」は、ソースコードがプログラミング言語の文法規則に従っているかを確認し、コードの構造を解析するプロセスです。　　
構文解析の目的は、ソースコードを意味のある構造（抽象構文木や構文木）に変換することです。

### 構文解析のプロセス

1. **字句解析（レキサー）**
   - ソースコードをトークンに分割します。トークンは、プログラムの基本的な構成要素（キーワード、識別子、演算子など）です。

2. **構文解析（パーサー）**
   - トークン列を受け取り、それがプログラミング言語の文法に従っているかを確認します。構文解析では、以下のような処理が行われます：
     - **文法の確認**: トークン列が文法規則に従っているかをチェックします。
     - **構文木の生成**: トークンの構造を示す構文木（または抽象構文木）を生成します。この木は、プログラムの文法構造を視覚的に表現します。

### 構文解析の主要な概念

1. **文法（Grammar）**
   - プログラミング言語の文法規則を定義したものです。通常、形式文法（例えば、BNF（Backus-Naur Form）やEBNF（Extended Backus-Naur Form））で記述されます。

2. **構文木（Parse Tree）**
   - ソースコードの構造をツリー形式で表現したものです。ノードは文法の構成要素を示し、子ノードは構成要素の部分を示します。

3. **抽象構文木（Abstract Syntax Tree, AST）**
   - 構文木の簡略化版で、プログラムの意味をより明確に示すツリーです。構文木から不要な情報を削除し、意味的に重要な要素だけを保持します。

4. **パーサー（Parser）**
   - トークン列を読み込み、構文規則に従って構文木または抽象構文木を生成するプログラムです。パーサーには、さまざまなタイプがあります（例：トップダウンパーサー、ボトムアップパーサー）。

### 構文解析のタイプ

- **トップダウンパーサー**
  - 文法規則のトップから始めて、トークン列を解析します。例として、再帰下降パーサーやLLパーサーがあります。

- **ボトムアップパーサー**
  - トークン列の下から始めて、文法規則を逆に適用していきます。例として、LRパーサーやLALRパーサーがあります。

### 構文解析の目的と重要性

- **文法の検証**: ソースコードが言語の文法に従っているかを検証します。
- **意味の理解**: コードの意味を理解するためのデータ構造（構文木やAST）を生成します。
- **次の処理ステップへの橋渡し**: コード生成や最適化など、コンパイラの次の処理段階に進むための基盤を提供します。

構文解析は、コンパイラがソースコードを理解し、正しく変換するための重要なステップであり、プログラムの構造を明確にする役割を担っています。

### 抽象構文木（AST）
抽象構文木（AST）はまさに階層構造を持つデータ構造です。抽象構文木は、プログラムの意味的な構造をツリー形式で表現したもので  
プログラムの構文要素をノードとして示し、ノード間の関係性を親子関係として示します。以下にその詳細と構造を説明します。

### 抽象構文木（AST）の構造

1. **ノード（Node）**
   - ASTの各ノードは、プログラムの特定の要素や構造を表します。ノードには、式、文、演算子、変数などが含まれます。例えば、演算子や関数呼び出し、条件文などがノードとして表現されます。

2. **階層（Hierarchy）**
   - ノードはツリーのように階層的に配置されます。親ノードは子ノードを持ち、子ノードはさらに子ノードを持つことができます。この階層構造によって、プログラムの構造や論理的な関係が表現されます。

3. **葉ノード（Leaf Node）**
   - ツリーの末端に位置し、子ノードを持たないノードです。通常、変数やリテラル値などの基本的な構成要素が葉ノードとして表されます。

4. **内部ノード（Internal Node）**
   - 一つ以上の子ノードを持つノードです。演算子や制御フロー構造（if文、ループなど）が内部ノードとして表されることが多いです。

### 抽象構文木の例

例えば、以下の簡単な数式：

```python
a + (b * c)
```

この数式の抽象構文木は次のようになります：

```
    +
   / \
  a   *
     / \
    b   c
```

ここでの構造は次のように解釈できます：

- `+` は親ノードで、`a` と `*` の2つの子ノードを持っています。
- `*` は親ノードで、`b` と `c` の2つの子ノードを持っています。
- `a`, `b`, `c` は葉ノードです。

### 抽象構文木の利点

1. **意味の抽象化**
   - ASTはプログラムの意味を抽象化して示します。構文の詳細や無関係な情報を排除し、プログラムの本質的な意味を捉えます。

2. **コードの最適化**
   - ASTを使うことで、コンパイラはプログラムの最適化を効率的に行うことができます。例えば、無駄な計算を削除する、より効率的なコードに変換するなどの最適化が可能です。

3. **コード生成**
   - ASTは、中間コードやターゲットコードの生成の基盤となります。構文木をもとに、実際の機械語やバイトコードを生成します。

4. **エラーチェック**
   - ASTを利用して、プログラムの意味的なエラーを検出することができます。例えば、型エラーや未定義の変数の使用などです。

### まとめ

抽象構文木（AST）は、プログラムの意味的な構造をツリー状に表現することで、ソースコードの論理的な構造を明確にし、コンパイラやインタプリタが効率的にコードを処理できるようにするための重要なデータ構造です。  
階層的な構造によって、プログラムの各部分がどのように組み合わさっているのかを理解しやすくし、次の処理ステップに進むための基盤を提供します。

---

その通りです。抽象構文木（AST）は、計算の優先順位や構文の階層構造を明確に示すため、計算式やプログラムの構造を直感的に理解するのに役立ちます。ASTを用いることで、計算の優先順位や処理の順序を効率的に管理できます。

### 単純な計算式の例

計算式の優先順位を示す例として、以下の計算式を考えます：

```plaintext
3 + 4 * 2
```

この式の抽象構文木（AST）は次のようになります：

```
    +
   / \
  3   *
     / \
    4   2
```

ここでは、`*`（掛け算）が`+`（足し算）よりも優先されることが示されています。したがって、まず`4 * 2`が計算され、その結果が`3`と足し合わされます。

### 複雑なプログラムの例

より複雑なプログラムの場合、ASTはプログラムの構造を示すだけでなく、次のような情報も示します：

1. **制御フロー**:
   - 条件分岐（if文）、ループ（for文、while文）などの制御構造がノードとして表現され、どの命令がどの条件下で実行されるかが示されます。

2. **関数呼び出しとスコープ**:
   - 関数呼び出しや変数スコープもASTで表現されます。関数の引数や戻り値、変数の宣言と使用の関係がツリー構造で示されます。

例えば、以下のようなプログラムを考えます：

```python
if (a > b) {
    c = a + d;
} else {
    c = b - d;
}
```

このプログラムのASTは次のようになります：

```
     if
    /  \
   >    else
  / \     / \
 a   b   -   c
           / \
          b   d
```

ここでは、条件`a > b`が最初に評価され、その結果に応じて`if`ブロックまたは`else`ブロックが実行されることが示されています。各ブロックの内部での計算（`a + d`または`b - d`）も階層的に表現されています。

### スタックや命令の順序

AST自体は、スタックや命令の具体的な順序を示すものではありませんが、次のステップとしての中間コード生成やコード最適化でその情報が利用されます。具体的な処理順序は、以下のような方法で管理されます：

1. **スタック操作**:
   - 四則演算や関数呼び出しなどの処理では、ASTをもとにスタック操作が行われることがあります。例えば、逆ポーランド記法（RPN）では、ASTからスタックを使って計算を行います。

2. **命令の順序**:
   - コンパイラはASTを基にして、低レベルな命令コードを生成します。このとき、処理の順序や最適化が行われ、効率的な命令列が生成されます。

3. **コード生成**:
   - ASTから中間コードやターゲットコードを生成する際に、どの命令がどの順序で実行されるかが決定されます。これは、プログラムの実行時のパフォーマンスや正確性に影響を与えます。

### まとめ

抽象構文木（AST）は、計算式やプログラムの構造を階層的に示すことで、計算の優先順位や構文の階層関係を明確にします。複雑なプログラムでは、ASTを利用して制御フローや関数呼び出し、変数のスコープなどを把握し、さらにそれを基にしてスタック操作や命令生成が行われます。ASTはプログラムの意味的な構造を理解するための重要なツールであり、コンパイラやインタプリタの多くのプロセスに役立ちます。
